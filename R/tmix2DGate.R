#' Gating wrapper based on flowClust::tmixFilter
#'
#' It basically calls flowClust to fit K clusters and construct K \code{ellipsoidGate} from them.
#'
#' @param fr \code{flowFrame}
#' @param channels \code{character} vector of channel/marker names (must be of length 2)
#' @param K \code{integer} the number of clusters to fit
#' @param quantile \code{numeric} vector of length K, which specifies the size of each cluster.
#' @param trans \code{numeric} must be 0
#' @param ... other arguments passed to \code{tmixFilter}
#' @return a \code{filters} object that contains K \code{filters} constructed from K clusters generated by flowClust
#' @export
#' @importFrom flowClust flowClust
#' @examples
#' \dontrun{
#' library(ggcyto)
#' dataDir <- system.file("extdata",package="flowWorkspaceData")
#' gs <- load_gs(list.files(dataDir, pattern = "gs_manual",full = TRUE))
#' fr <- getData(gs[[1]], "CD3+")
#' gates <- tmix2DGate(fr = fr, channels = c("<B710-A>", "<B710-A>"), K = 2, quantile = 0.7)
#' autoplot(fr, "CD8","CD4") + geom_gate(gates)
#' }
tmix2DGate <- function(fr, channels, K, quantile = 0.85, trans = 0, ...){
  if(length(channels)!=2)
    stop("2D gate must have two channels!")
  if(trans != 0)
    stop("trans must be 0!")

  tmix_results <- flowClust(fr, varNames = channels, K = K, trans = trans,...)

  #construct polygon gates
  gates <- mapply(1:K, quantile, FUN = function(k, q, filter){
        openCyto:::.getEllipseGate(filter = tmix_results
                , include = k,
                quantile = q
                ,trans = 0)
      })
  filters(gates)
}
