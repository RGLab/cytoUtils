#' Gating wrapper based on flowClust::tmixFilter
#' 
#' It basically calls flowClust to fit K clusters and construct K \code{ellipsoidGate} from them.
#' 
#' @param fr \code{flowFrame}
#' @param channels \code{character} vector of channel/marker names (must be of length 2)
#' @param K \code{integer} the number of clusters to fit
#' @param quantile \code{numeric} vector of length K, which specifies the size of each cluster.
#' @param trans \code{numeric} must be 0
#' @param ... other arguments passed to \code{tmixFilter}
#' @return a \code{filters} object that contains K \code{filters} constructed from K clusters generated by flowClust
#' @export
#' @examples 
#' \dontrun{

#'     gates <- tmix2DGate(fr = fr, channels = c("CD4", "CD8"), K = 2, quantile = 0.7)  
#'     autoplot(fr, "CD8","CD4") + geom_gate(gates)

#' }
tmix2DGate <- function(fr, channels, K, quantile = 0.85, trans = 0, ...){
  if(length(channels)!=2)
    stop("2D gate must have two channels!")
  if(trans != 0)
    stop("trans must be 0!")
  
  tmix_results <- openCyto:::.flowClustFast(fr, channels, K = K, trans = trans,...) 
    
  #construct polygon gates 
  gates <- mapply(1:K, quantile, FUN = function(k, q, filter){
        openCyto:::.getEllipseGate(filter = tmix_results
                , include = k,
                quantile = q
                ,trans = 0)
      })
  filters(gates)
}